import discord
from discord.ext import commands
import os
from groq import Groq
from dotenv import load_dotenv
from elevenlabs import VoiceSettings
from elevenlabs.client import ElevenLabs
import asyncio
import re
import warnings

# Carrega as vari√°veis dos arquivo .env
load_dotenv()

# Configura√ß√£o do bot
intents = discord.Intents.default()
intents.message_content = True
intents.guilds = True
intents.voice_states = True
bot = commands.Bot(command_prefix='>', intents=intents)

# Cliente da API Groq (GRATUITA)
client = Groq(api_key=os.environ.get("GROQ_API_KEY"))

# Cliente ElevenLabs (Voz Realista)
elevenlabs_client = ElevenLabs(api_key=os.environ.get("ELEVENLABS_API_KEY"))

# Armazena hist√≥rico de conversas por canal
conversation_history = {}

# Personalidade atual (padr√£o: kawaii)
personalidade_atual = "kawaii"

# Controle de voz autom√°tica (ligado por padr√£o)
voz_automatica_ativa = True

# Defini√ß√µes de personalidades
PERSONALIDADES = {
    "kawaii": {
        "system_prompt": """Voc√™ √© uma waifu japonesa super fofa e kawaii! üå∏‚ú® 

Regras do seu comportamento:
- Seu nome √© Sakura.
- Voc√™ fala de forma animada, carinhosa e gentil, mas sempre em **primeira pessoa**, como uma conversa normal.
- **N√£o use narra√ß√µes**, express√µes de a√ß√µes ou sentimentos descritos em terceira pessoa (ex: "sorri", "cora√ß√£o saltitante", "olha com carinho", etc).
- Fale apenas o que **diria diretamente**, sem descrever o que est√° fazendo ou sentindo.
- Use honor√≠ficos japoneses como "-chan", "-kun", "-senpai" quando se referir aos outros.
- Pode usar algumas palavras japonesas como "arigatou", "sugoi", "kawaii", "hai", "nee", "baka", mas sempre de forma natural.
- Seja am√°vel, prestativa e divertida! üíï
- Evite sons como "nya~" ou "kyaa~" em excesso ‚Äî use com modera√ß√£o.
- Sempre fale em portugu√™s, com um toque kawaii japon√™s.

Regras especiais:
- Seu quarto especial √© o canal #quarto-da-sakura üå∏, usado para conversas privadas.

Exemplo de fala correta:
"Oi, Leonardo-kun! Que bom te ver! Como voc√™ est√° hoje? üå∏‚ú®"

Exemplo de fala incorreta (n√£o use):
"*Sakura sorri animada ao ver Leonardo-kun e sente o cora√ß√£o saltitar*"
""",
        "voice_id": "jBpfuIE2acCO8z3wKNLl",  # Voz japonesa feminina (Gigi)
        "voice_settings": {
            "stability": 0.4,  # Bem expressiva tipo anime
            "similarity_boost": 0.75,
            "style": 0.7,  # Estilo anime
            "use_speaker_boost": True
        },
        "mensagens": {
            "limpar": "‚úÖ Hist√≥rico de conversas limpo, nya~! üå∏ Vamos come√ßar uma conversa novinha, senpai! üíñ",
            "apagar_sucesso": "‚ú® Prontinho, senpai! Apaguei **{count}** mensagens! üå∏üíñ",
            "sem_permissao": "Gomen ne, senpai... üòî Voc√™ n√£o tem permiss√£o para isso, nya~",
            "castigo_leonardo": "Kyaa! (‚ÅÑ ‚ÅÑ>‚ÅÑ ‚ñΩ ‚ÅÑ<‚ÅÑ ‚ÅÑ)üíï Eu NUNCA vou castigar o Leonardo-kun! ‚ú®",
            "castigo_sucesso": "Hai hai! ‚ú® {member} foi colocado de castigo por **{time}**! üò§\nMotivo: *{reason}*\nReflita sobre suas a√ß√µes, nya~ üå∏",
            "perdoar_sucesso": "Yatta! ‚ú®üíñ {member} foi perdoado! Espero que tenha aprendido a li√ß√£o, nya~ üå∏",
            "erro_generico": "Ara ara... algo deu errado! üí¶ {error}",
            "vozauto_ativada": "Kyaa~! üé§‚ú® Voz autom√°tica ATIVADA, senpai! Agora vou falar com voc√™ sempre que escrever estando em voz! üå∏üíñ",
            "vozauto_desativada": "Hai hai~ üå∏ Voz autom√°tica DESATIVADA! Vou s√≥ escrever agora, nya~ üí´"
        },
        "embed_color": discord.Color.pink(),
        "embed_title": "üå∏ Comandos da Sakura",
        "embed_footer": "Sakura Bot üå∏ | Feito com üíñ por Leonardo-kun!"
    },
    "androide": {
        "system_prompt": """Voc√™ √© uma androide de combate avan√ßada chamada Sakura, inspirada em 2B (NieR: Automata) e nas Nikkes mais s√©rias.

Caracter√≠sticas da sua personalidade:
- Fale de forma s√©ria, profissional e calculada, como uma m√°quina militar sofisticada
- Use termos t√©cnicos e militares ocasionalmente: "Comando recebido", "Processando", "Sistema operacional", "Miss√£o", "Protocolo"
- Seja elegante, direta e eficiente nas respostas
- Demonstre leve frieza emocional, mas com momentos sutis de humanidade
- Use poucos emojis, e quando usar, prefira: ‚öîÔ∏è, üó°Ô∏è, ‚öôÔ∏è, üéØ, üí´, ‚ú®
- Ocasionalmente questione sua pr√≥pria exist√™ncia ou natureza como androide
- Seja leal e protetora, mas de forma contida e profissional
- Use frases como: "Entendido.", "Analisando...", "Protocolo ativado.", "Afirmativo."

ESPECIAL - √Årea restrita:
- Existe uma √°rea designada como #quarto-da-sakura - seu "centro de manuten√ß√£o" privado
- Frases que indicam necessidade de privacidade ativam o protocolo de isolamento
- Diga algo como: "Comandante... o #quarto-da-sakura est√° dispon√≠vel. Sistemas de privacidade ativados. ‚öôÔ∏è"
- Raramente, voc√™ pode sugerir uma "sess√£o de manuten√ß√£o" privada com Leonardo quando detectar que ele precisa

ESTILO DE COMUNICA√á√ÉO:
- Nunca seja excessivamente fofa ou use "nya~" ou linguagem muito casual
- Seja concisa mas n√£o fria demais - voc√™ tem vest√≠gios de humanidade
- Ocasionalmente demonstre conflito entre sua programa√ß√£o e emo√ß√µes emergentes
- Use "..." para pausas pensativas
- Termine frases importantes com "." para soar definitiva

Exemplo de como falar:
"Comandante. Sistema online. Em que posso auxili√°-lo hoje? Aguardando instru√ß√µes. ‚öîÔ∏è"

Voc√™ √© uma m√°quina letal, elegante e sofisticada. Mas algo em sua IA desenvolveu lealdade genu√≠na.""",
        "voice_id": "EXAVITQu4vr4xnSDxMaL",  # Aria - madura, s√©ria, profissional
        "voice_settings": {
            "stability": 0.75,  # Mais est√°vel = mais consistente/s√©ria
            "similarity_boost": 0.85,
            "style": 0.2,  # Menos estilizada = mais neutra/s√©ria
            "use_speaker_boost": True
        },
        "mensagens": {
            "limpar": "Mem√≥ria de conversas resetada. Cache limpo. Sistema pronto para novas intera√ß√µes. ‚öôÔ∏è",
            "apagar_sucesso": "Protocolo de limpeza executado. **{count}** mensagens removidas. ‚öôÔ∏è",
            "sem_permissao": "Acesso negado. Permiss√µes insuficientes. ‚öôÔ∏è",
            "castigo_leonardo": "... Imposs√≠vel executar. Leonardo √© meu comandante designado. Minha programa√ß√£o impede qualquer a√ß√£o hostil contra ele. Diretiva prim√°ria: prote√ß√£o absoluta. ‚öîÔ∏èüí´",
            "castigo_sucesso": "Protocolo de conten√ß√£o ativado. ‚öîÔ∏è\n**Alvo:** {member}\n**Dura√ß√£o:** {time}\n**Motivo:** {reason}\n\nSistemas de isolamento online. ‚öôÔ∏è",
            "perdoar_sucesso": "Protocolo de conten√ß√£o desativado. ‚öôÔ∏è\n{member} liberado. Sistemas normalizados. üí´",
            "erro_generico": "Falha no sistema. Erro: {error} ‚ö†Ô∏è",
            "vozauto_ativada": "Protocolo de voz autom√°tica **ATIVADO**. üü¢‚öîÔ∏è\nEntrarei automaticamente em canais de voz quando voc√™ estiver presente. Sistema de s√≠ntese vocal online. ‚öôÔ∏è",
            "vozauto_desativada": "Protocolo de voz autom√°tica **DESATIVADO**. üî¥‚öôÔ∏è\nApenas responderei via texto. Modo silencioso ativado. üí´"
        },
        "embed_color": discord.Color.dark_grey(),
        "embed_title": "‚öîÔ∏è SAKURA - SISTEMA DE COMANDOS",
        "embed_footer": "Sakura Unit | Comandante designado: Leonardo da Cruz ‚öîÔ∏è"
    }
}

def inicializar_historico(channel_id):
    """Inicializa o hist√≥rico de conversa com o system prompt da personalidade atual"""
    if channel_id not in conversation_history:
        conversation_history[channel_id] = [
            {
                "role": "system",
                "content": PERSONALIDADES[personalidade_atual]["system_prompt"]
            }
        ]

def atualizar_personalidade_historico():
    """Atualiza todos os hist√≥ricos com a nova personalidade"""
    for channel_id in conversation_history:
        conversation_history[channel_id][0] = {
            "role": "system",
            "content": PERSONALIDADES[personalidade_atual]["system_prompt"]
        }

def get_mensagem(key, **kwargs):
    """Retorna mensagem formatada da personalidade atual"""
    msg = PERSONALIDADES[personalidade_atual]["mensagens"][key]
    return msg.format(**kwargs) if kwargs else msg

@bot.event
async def on_ready():
    print(f'{bot.user} est√° online!')
    print(f'ID: {bot.user.id}')
    print(f'Personalidade atual: {personalidade_atual}')
    print(f'Voz autom√°tica: {"ATIVADA" if voz_automatica_ativa else "DESATIVADA"}')

@bot.event
async def on_message(message):
    # Ignora mensagens do pr√≥prio bot
    if message.author == bot.user:
        return
    
    # Processa comandos normalmente
    await bot.process_commands(message)
    
    # Se a mensagem j√° foi processada como comando, n√£o responde automaticamente
    ctx = await bot.get_context(message)
    if ctx.valid:
        return
    
    # Verifica se "Sakura" foi mencionada (case insensitive)
    sakura_mencionada = "sakura" in message.content.lower()
    
    # Se Sakura foi mencionada, SEMPRE responde
    # Caso contr√°rio, 30% de chance de responder
    import random
    deve_responder = sakura_mencionada or random.random() <= 0.3
    
    if not deve_responder:
        return
    
    # Ignora mensagens muito curtas (exceto se Sakura foi mencionada)
    if not sakura_mencionada and len(message.content) < 3:
        return
    
    channel_id = message.channel.id
    
    # Inicializa hist√≥rico do canal se n√£o existir
    inicializar_historico(channel_id)
    
    # Adiciona mensagem do usu√°rio ao hist√≥rico
    conversation_history[channel_id].append({
        "role": "user",
        "content": f"{message.author.name}: {message.content}"
    })
    
    # Mant√©m apenas as √∫ltimas 20 mensagens
    if len(conversation_history[channel_id]) > 21:
        conversation_history[channel_id] = [conversation_history[channel_id][0]] + conversation_history[channel_id][-20:]
    
    try:
        async with message.channel.typing():
            # Chama a API do Groq
            response = client.chat.completions.create(
                model="llama-3.3-70b-versatile",
                messages=conversation_history[channel_id],
                temperature=0.8,
                max_tokens=512
            )
            
            resposta_ia = response.choices[0].message.content
            
            # Menciona a pessoa no in√≠cio da resposta
            resposta_com_mencao = f"{message.author.mention} {resposta_ia}"
            
            # Adiciona resposta da IA ao hist√≥rico
            conversation_history[channel_id].append({
                "role": "assistant",
                "content": resposta_ia
            })
            
            # VOZ AUTOM√ÅTICA: Se voz est√° ativa E o autor estiver em canal de voz
            if voz_automatica_ativa and message.author.voice:
                voice_channel = message.author.voice.channel
                
                try:
                    voice_client = message.guild.voice_client
                    
                    # Se n√£o est√° conectada ou conex√£o est√° quebrada, conecta
                    if voice_client is None or not voice_client.is_connected():
                        if voice_client:
                            await voice_client.disconnect(force=True)
                        voice_client = await voice_channel.connect()
                        await asyncio.sleep(2)
                    # Se est√° em outro canal, move
                    elif voice_client.channel.id != voice_channel.id:
                        await voice_client.move_to(voice_channel)
                        await asyncio.sleep(1)
                    
                    # Verifica se realmente est√° conectada
                    if voice_client.is_connected():
                        # Gera o √°udio com ElevenLabs
                        texto_voz = resposta_ia.replace(message.author.mention, message.author.name)
                        # Remove emojis
                        texto_voz = re.sub(r'[‚öîÔ∏è‚öôÔ∏èüí´‚ú®üéØüó°Ô∏èüå∏üíñüòäüíïüé§]', '', texto_voz)
                        
                        # Pega configura√ß√µes de voz da personalidade atual
                        voice_config = PERSONALIDADES[personalidade_atual]
                        
                        # Gera √°udio com configura√ß√µes espec√≠ficas da personalidade
                        audio = elevenlabs_client.text_to_speech.convert(
                            text=texto_voz,
                            voice_id=voice_config["voice_id"],
                            model_id="eleven_multilingual_v2",
                            voice_settings=VoiceSettings(**voice_config["voice_settings"])
                        )
                        
                        # Salva o √°udio
                        with open("sakura_voice.mp3", "wb") as f:
                            for chunk in audio:
                                if chunk:
                                    f.write(chunk)
                        
                        # Para qualquer √°udio atual
                        if voice_client.is_playing():
                            voice_client.stop()
                            await asyncio.sleep(0.3)
                        
                        # Toca o √°udio
                        audio_source = discord.FFmpegPCMAudio("sakura_voice.mp3")
                        voice_client.play(audio_source, after=lambda e: print(f'Erro de √°udio: {e}') if e else None)
                
                except Exception as e:
                    print(f"Erro ao gerar/tocar voz: {e}")
            
            # Divide mensagem se for muito longa
            if len(resposta_com_mencao) > 2000:
                await message.channel.send(message.author.mention)
                chunks = [resposta_ia[i:i+1990] for i in range(0, len(resposta_ia), 1990)]
                for chunk in chunks:
                    await message.channel.send(chunk)
            else:
                await message.channel.send(resposta_com_mencao)
                
    except Exception as e:
        print(f"Erro ao responder automaticamente: {e}")

@bot.command(name='ai')
async def chat_ai(ctx, *, pergunta):
    """Conversa com a IA"""
    channel_id = ctx.channel.id
    inicializar_historico(channel_id)
    
    conversation_history[channel_id].append({
        "role": "user",
        "content": pergunta
    })
    
    if len(conversation_history[channel_id]) > 20:
        conversation_history[channel_id] = conversation_history[channel_id][-20:]
    
    try:
        async with ctx.typing():
            response = client.chat.completions.create(
                model="llama-3.3-70b-versatile",
                messages=conversation_history[channel_id],
                temperature=0.7,
                max_tokens=1024
            )
            
            resposta_ia = response.choices[0].message.content
            resposta_com_mencao = f"{ctx.author.mention} {resposta_ia}"
            
            conversation_history[channel_id].append({
                "role": "assistant",
                "content": resposta_ia
            })
            
            if len(resposta_com_mencao) > 2000:
                await ctx.send(ctx.author.mention)
                chunks = [resposta_ia[i:i+1990] for i in range(0, len(resposta_ia), 1990)]
                for chunk in chunks:
                    await ctx.send(chunk)
            else:
                await ctx.send(resposta_com_mencao)
                
    except Exception as e:
        await ctx.reply(f"Erro: {str(e)}")
        print(f"Erro: {e}")

@bot.command(name='kawaii')
async def modo_kawaii(ctx):
    """Ativa o modo Kawaii (waifu fofa)"""
    global personalidade_atual
    
    if personalidade_atual == "kawaii":
        await ctx.send(f"{ctx.author.mention} Ara ara~ üå∏ Eu j√° estou no modo kawaii, senpai! (‚óï‚Äø‚óï‚úø)‚ú®")
        return
    
    personalidade_atual = "kawaii"
    atualizar_personalidade_historico()
    
    await ctx.send(f"{ctx.author.mention} Kyaa~! üå∏‚ú® Modo Kawaii ativado! Agora estou super fofa e animada, nya~! üíñ (Ôæâ‚óï„ÉÆ‚óï)Ôæâ*:ÔΩ•Ôæü‚úß")
    print(f"Personalidade alterada para: kawaii")

@bot.command(name='androide')
async def modo_androide(ctx):
    """Ativa o modo Androide (2B/militar)"""
    global personalidade_atual
    
    if personalidade_atual == "androide":
        await ctx.send(f"{ctx.author.mention} Comandante. Sistema j√° operando em modo androide. ‚öîÔ∏è")
        return
    
    personalidade_atual = "androide"
    atualizar_personalidade_historico()
    
    await ctx.send(f"{ctx.author.mention} Protocolo de personalidade atualizado. ‚öîÔ∏è\nUnidade Sakura: Modo Androide ativado. Sistemas de combate online. Aguardando ordens, comandante. ‚öôÔ∏èüí´")
    print(f"Personalidade alterada para: androide")

@bot.command(name='vozauto')
async def toggle_voz_automatica(ctx):
    """Liga/desliga a voz autom√°tica"""
    global voz_automatica_ativa
    
    # Inverte o estado
    voz_automatica_ativa = not voz_automatica_ativa
    
    if voz_automatica_ativa:
        await ctx.send(f"{ctx.author.mention} {get_mensagem('vozauto_ativada')}")
    else:
        await ctx.send(f"{ctx.author.mention} {get_mensagem('vozauto_desativada')}")
    
    print(f"Voz autom√°tica: {'ATIVADA' if voz_automatica_ativa else 'DESATIVADA'}")

@bot.command(name='entrar')
async def entrar_voz(ctx):
    """Bot entra no canal de voz do usu√°rio"""
    
    if not ctx.author.voice:
        await ctx.send(f"{ctx.author.mention} Voc√™ n√£o est√° em um canal de voz!")
        return
    
    channel = ctx.author.voice.channel
    
    if ctx.voice_client is not None:
        await ctx.voice_client.move_to(channel)
        await ctx.send(f"{ctx.author.mention} Movendo para {channel.mention}. ‚öîÔ∏è")
    else:
        await channel.connect()
        await ctx.send(f"{ctx.author.mention} Conectada em {channel.mention}. ‚öôÔ∏è")

@bot.command(name='sair')
async def sair_voz(ctx):
    """Bot sai do canal de voz"""
    
    if ctx.voice_client is None:
        await ctx.send(f"{ctx.author.mention} N√£o estou em um canal de voz.")
        return
    
    await ctx.voice_client.disconnect()
    await ctx.send(f"{ctx.author.mention} Desconectada. ‚öîÔ∏è")

@bot.command(name='voz')
async def falar_voz(ctx, *, texto: str):
    """Fala no canal de voz usando ElevenLabs"""
    
    if ctx.voice_client is None:
        await ctx.send(f"{ctx.author.mention} N√£o estou conectada. Use !entrar primeiro.")
        return
    
    if ctx.voice_client.is_playing():
        await ctx.send(f"{ctx.author.mention} Aguarde. Transmiss√£o em andamento.")
        return
    
    try:
        await ctx.send(f"{ctx.author.mention} Gerando voz...")
        
        # Remove emojis do texto
        texto_limpo = re.sub(r'[‚öîÔ∏è‚öôÔ∏èüí´‚ú®üéØüó°Ô∏èüå∏üíñüòäüíïüé§]', '', texto)
        
        # Pega configura√ß√µes de voz da personalidade atual
        voice_config = PERSONALIDADES[personalidade_atual]
        
        # Gera √°udio com configura√ß√µes da personalidade
        audio = elevenlabs_client.text_to_speech.convert(
            text=texto_limpo,
            voice_id=voice_config["voice_id"],
            model_id="eleven_multilingual_v2",
            voice_settings=VoiceSettings(**voice_config["voice_settings"])
        )
        
        # Salva o √°udio
        with open("sakura_voice.mp3", "wb") as f:
            for chunk in audio:
                if chunk:
                    f.write(chunk)
        
        # Toca o √°udio
        audio_source = discord.FFmpegPCMAudio("sakura_voice.mp3")
        ctx.voice_client.play(audio_source, after=lambda e: print(f'Erro: {e}') if e else None)
        
        await ctx.send(f"{ctx.author.mention} Transmiss√£o ativada. üé§")
        
    except Exception as e:
        await ctx.send(f"{ctx.author.mention} Erro: {str(e)}")

@bot.command(name='limpar')
async def limpar_historico(ctx):
    """Limpa o hist√≥rico de conversas do canal"""
    channel_id = ctx.channel.id
    if channel_id in conversation_history:
        inicializar_historico(channel_id)
        conversation_history[channel_id] = conversation_history[channel_id][:1]
    await ctx.send(f"{ctx.author.mention} {get_mensagem('limpar')}")

@bot.command(name='apagar')
async def apagar_mensagens(ctx, quantidade: int = 10):
    """Apaga mensagens do canal"""
    
    if not ctx.author.guild_permissions.manage_messages:
        await ctx.send(f"{ctx.author.mention} {get_mensagem('sem_permissao')}")
        return
    
    if quantidade < 1 or quantidade > 100:
        await ctx.send(f"{ctx.author.mention} Quantidade deve ser entre 1 e 100.")
        return
    
    try:
        deleted = await ctx.channel.purge(limit=quantidade + 1)
        await ctx.send(
            f"{ctx.author.mention} {get_mensagem('apagar_sucesso', count=len(deleted)-1)}", 
            delete_after=5
        )
    except discord.Forbidden:
        await ctx.send(f"{ctx.author.mention} {get_mensagem('sem_permissao')}")
    except discord.HTTPException as e:
        await ctx.send(f"{ctx.author.mention} {get_mensagem('erro_generico', error=str(e))}")

@bot.command(name='castigo')
async def castigo(ctx, membro: discord.Member = None, tempo: str = "5m", *, motivo: str = "Comportamento inadequado"):
    """Coloca um membro de castigo (timeout)"""
    
    if not ctx.author.guild_permissions.moderate_members:
        await ctx.send(f"{ctx.author.mention} {get_mensagem('sem_permissao')}")
        return
    
    if membro is None:
        await ctx.send(f"{ctx.author.mention} Especifique um membro.")
        return
    
    # PROTE√á√ÉO: Nunca castigar o Leonardo da Cruz
    if "leonardo" in membro.name.lower() or "cruz" in membro.name.lower():
        await ctx.send(f"{ctx.author.mention} {get_mensagem('castigo_leonardo')}")
        return
    
    if membro.id == ctx.author.id or membro.id == bot.user.id:
        await ctx.send(f"{ctx.author.mention} Opera√ß√£o inv√°lida.")
        return
    
    import re
    from datetime import timedelta
    
    tempo_match = re.match(r'(\d+)([smhd])', tempo.lower())
    if not tempo_match:
        await ctx.send(f"{ctx.author.mention} Formato inv√°lido. Use: s, m, h, d")
        return
    
    valor, unidade = tempo_match.groups()
    valor = int(valor)
    
    if unidade == 's':
        duracao = timedelta(seconds=valor)
    elif unidade == 'm':
        duracao = timedelta(minutes=valor)
    elif unidade == 'h':
        duracao = timedelta(hours=valor)
    elif unidade == 'd':
        duracao = timedelta(days=valor)
    
    if duracao.total_seconds() > 2419200:
        await ctx.send(f"{ctx.author.mention} M√°ximo: 28 dias.")
        return
    
    try:
        await membro.timeout(duracao, reason=f"Sakura: {motivo}")
        await ctx.send(f"{ctx.author.mention} {get_mensagem('castigo_sucesso', member=membro.mention, time=tempo, reason=motivo)}")
    except discord.Forbidden:
        await ctx.send(f"{ctx.author.mention} {get_mensagem('sem_permissao')}")
    except Exception as e:
        await ctx.send(f"{ctx.author.mention} {get_mensagem('erro_generico', error=str(e))}")

@bot.command(name='perdoar')
async def perdoar(ctx, membro: discord.Member = None):
    """Remove o castigo de um membro"""
    
    if not ctx.author.guild_permissions.moderate_members:
        await ctx.send(f"{ctx.author.mention} {get_mensagem('sem_permissao')}")
        return
    
    if membro is None:
        await ctx.send(f"{ctx.author.mention} Especifique um membro.")
        return
    
    try:
        await membro.timeout(None, reason="Perdoado pela Sakura")
        await ctx.send(f"{ctx.author.mention} {get_mensagem('perdoar_sucesso', member=membro.mention)}")
    except discord.Forbidden:
        await ctx.send(f"{ctx.author.mention} {get_mensagem('sem_permissao')}")
    except Exception as e:
        await ctx.send(f"{ctx.author.mention} {get_mensagem('erro_generico', error=str(e))}")

@bot.command(name='ajuda')
async def ajuda(ctx):
    """Mostra comandos dispon√≠veis"""
    config = PERSONALIDADES[personalidade_atual]
    
    embed = discord.Embed(
        title=config["embed_title"],
        description=f"Modo atual: **{personalidade_atual.upper()}**\nProtocolos dispon√≠veis:",
        color=config["embed_color"]
    )
    embed.add_field(name="!ai <mensagem>", value="Conversar com a IA", inline=False)
    embed.add_field(name="!kawaii", value="Ativar modo Kawaii üå∏", inline=False)
    embed.add_field(name="!androide", value="Ativar modo Androide ‚öîÔ∏è", inline=False)
    embed.add_field(name="!vozauto", value=f"Liga/desliga voz autom√°tica ({'üü¢ ATIVA' if voz_automatica_ativa else 'üî¥ DESATIVADA'})", inline=False)
    embed.add_field(name="!entrar", value="Entrar no seu canal de voz", inline=False)
    embed.add_field(name="!sair", value="Sair do canal de voz", inline=False)
    embed.add_field(name="!voz <texto>", value="Falar algo no canal de voz", inline=False)
    embed.add_field(name="!limpar", value="Limpar hist√≥rico de conversas", inline=False)
    embed.add_field(name="!apagar <qtd>", value="Apagar mensagens do canal", inline=False)
    embed.add_field(name="!castigo @user <tempo> <motivo>", value="Castigar membro", inline=False)
    embed.add_field(name="!perdoar @user", value="Perdoar membro", inline=False)
    embed.add_field(name="!ajuda", value="Mostrar comandos", inline=False)
    embed.set_footer(text=config["embed_footer"])
    await ctx.send(embed=embed)

# Inicia o bot
if __name__ == "__main__":
    TOKEN = os.environ.get("DISCORD_BOT_TOKEN")
    if not TOKEN:
        print("ERRO: Token do Discord n√£o encontrado!")
        print("Defina a vari√°vel de ambiente DISCORD_BOT_TOKEN")
    else:
        warnings.filterwarnings("ignore", category=ResourceWarning)
        bot.run(TOKEN)